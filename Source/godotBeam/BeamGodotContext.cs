using System.Collections.Generic;
using System.Threading.Tasks;
using Beamable.Api;
using Beamable.Api.Autogenerated.Models;
using Beamable.Api.Autogenerated.Realms;
using Beamable.Common;
using Beamable.Common.Api;
using Beamable.Common.Api.Auth;
using Beamable.Common.Content;
using Beamable.Common.Dependencies;
using Beamable.Config;
using Beamable.Connection;
using Beamable.Player;
using Godot;
using UnityEngine;
using EmptyResponse = Beamable.Common.Api.EmptyResponse;
using ExternalIdentity = Beamable.Common.Api.Auth.ExternalIdentity;
using TokenResponse = Beamable.Common.Api.Auth.TokenResponse;

namespace GodotBeamable.BeamGodot
{
    public class BeamGodotContext : IUserContext
    {
        /// <summary>
        /// A static <see cref="BeamContext"/> that uses a <see cref="PlayerCode"/> of an empty string.
        /// By default, the default context will persist between scene reloads. If you need to dispose it, you'll
        /// need to manually invoke <see cref="Stop"/>
        /// </summary>
        public static BeamGodotContext Default => Instantiate();

        /// <summary>
        /// The <see cref="PlayerCode"/> is the name of a player's slot on the device. The <see cref="Default"/> context uses an empty string,
        /// but you could use values like "player1" and "player2" to enable a feature like couch-coop.
        /// </summary>
        public string PlayerCode { get; private set; }

        /// <summary>
        /// The User that this context is authenticated with. Any web-calls that are made from this <see cref="BeamContext"/> are made by this User
        /// </summary>
        public ObservableUser AuthorizedUser = new ObservableUser
        {
            Value = new User
            {
                thirdPartyAppAssociations = new List<string>(),
                external = new List<ExternalIdentity>(),
                deviceIds = new List<string>(),
                scopes = new List<string>()
            }
        };

        public long PlayerId => AuthorizedUser?.Value?.id ?? 0;

        private static Dictionary<string, BeamGodotContext> _playerCodeToContext =
            new Dictionary<string, BeamGodotContext>();

        public Dictionary<string, string> Stats { get; private set; } = new Dictionary<string, string>();
        public long UserId => PlayerId;
        public GodotRequester Requester => _requester;
        public IDependencyProvider ServiceProvider => _serviceScope;
        public IAuthApi Auth => _authApi;

        public string Cid => _requester.Cid;
        public string Pid => _requester.Pid;
        public AccessToken AccessToken => _requester.Token;
        public Promise<Unit> OnReady => _initPromise;
        private GodotRequester _requester;
        private readonly IAuthApi _authApi;
        private Promise _initPromise;
        private IDependencyProviderScope _serviceScope;
        private AccessTokenStorage _tokenStorage;
        private IAuthApi _authService;

        /// <summary>
        /// Finds or creates the first <see cref="BeamGodotContext"/> that matches the given <see cref="BeamGodotContext.PlayerCode"/> value
        /// </summary>
        public static BeamGodotContext ForPlayer(string playerCode = "") => Instantiate(playerCode: playerCode);

        /// <summary>
        /// Finds all <see cref="BeamGodotContext"/>s that have been created. This may include disposed contexts.
        /// </summary>
        public static IEnumerable<BeamGodotContext> All => _playerCodeToContext.Values;

        public static BeamGodotContext Instantiate(string playerCode = null,
            IDependencyBuilder dependencyBuilder = null)
        {
            playerCode ??= "default";
            if (_playerCodeToContext.TryGetValue(playerCode, out var context))
                return context;
            var ctx = new BeamGodotContext();
            var cid = ConfigDatabase.GetString("cid");
            var pid = ConfigDatabase.GetString("pid");
            dependencyBuilder = dependencyBuilder ?? Beam.DependencyBuilder;

            ctx.Init(cid, pid, playerCode, dependencyBuilder);
            _playerCodeToContext[playerCode] = ctx;
            return ctx;
        }

        private void Init(string cid, string pid, string playerCode, IDependencyBuilder builder)
        {
            GD.Print($"Started Init: {cid}, {pid}, {playerCode}");
            _initPromise = new Promise();
            PlayerCode = playerCode;
            builder = builder.Clone();
            RegisterServices(builder);
            _serviceScope = builder.Build();
            InitServices(cid, pid);
#pragma warning disable CS4014 // Because this call is not awaited, execution of the current method continues before the call is completed
            InitProcedure().Error(Debug.LogException).Then(_ => _initPromise.CompleteSuccess());
#pragma warning restore CS4014 // Because this call is not awaited, execution of the current method continues before the call is completed
        }

        async Promise InitProcedure()
        {
            GD.Print("Started Init procedure");
            var token = _tokenStorage.LoadTokenForRealmImmediate(Cid, Pid);
            GD.Print($"Token: {token?.Token}");
            _requester.Token = _tokenStorage.LoadTokenForRealmImmediate(Cid, Pid);

            var hasInternet = true; //await _connectivityChecker.ForceCheck();

            var hasNoToken = AccessToken == null;
            var hasOfflineToken = AccessToken?.Token == Constants.Commons.OFFLINE;
            var needsToken = hasNoToken || hasOfflineToken;

            // if (!hasInternet)
            // {
            // 	await SetupWithoutConnection();
            // 	// when internet reconnects, re-run the init. 
            // 	_connectivityService.OnReconnectOnce(() => InitProcedure(), -100);
            // }
            // else
            {
                try
                {
                    await SetupWithConnection();
                }
                catch (NoConnectivityException)
                {
                    // we tried so hard to avoid this.
                    Debug.LogWarning("Lost internet during Beamable initiation. unpredictable behaviour may occur.");
                }
            }

            async Promise SetupWithConnection()
            {
                GD.Print("Started SetupWithConnection");
                if (needsToken)
                {
                    GD.Print("Create user");
                    var rsp = await _authService.CreateUser();
                    await SaveToken(rsp);
                }
                else if (AccessToken.IsExpired)
                {
                    GD.Print("refresh expired token");
                    var rsp = await _authService.LoginRefreshToken(AccessToken.RefreshToken);
                    await SaveToken(rsp);
                }

                await SetupGetUser();
                var connection = SetupBeamableNotificationChannel();
                // var session = SetupNewSession();
                // var purchase = SetupPurchaser();
                await connection;
                await GetStatsFromServer();
                // await Promise.Sequence(connection, session, purchase);
                //
                // SetupEmitEvents();
            }

            async Promise SetupBeamableNotificationChannel()
            {
                RealmConfiguration config = await ServiceProvider.GetService<IRealmsApi>().GetClientDefaults();

                string provider = config.websocketConfig.provider ?? "pubnub";
                if (provider == "pubnub")
                    return;
                // Let's make sure that we get a fresh new JWT before attempting to connect.
                await _requester.RefreshToken();
                Debug.Log($"There is URI: {config.websocketConfig.uri}");
                await InitStep_StartWebsocket(config.websocketConfig.uri);
            }

            async Promise SetupGetUser()
            {
                var user = await _authService.GetUser();
                AuthorizedUser.Value = user;
            }
        }

        private async Promise InitStep_StartWebsocket(string socketUri)
        {
            var _ = _serviceScope.GetService<BeamableSubscriptionManager>();
            var connection = _serviceScope.GetService<IBeamableConnection>();
            await connection.Connect(socketUri, _requester.Token);
        }

        private async Promise SaveToken(TokenResponse rsp)
        {
            ClearToken();
            var token = new AccessToken(_tokenStorage,
                Cid,
                Pid,
                rsp.access_token,
                rsp.refresh_token,
                rsp.expires_in);

            _requester.Token = token;
            await _requester.Token.Save();
        }

        private void ClearToken()
        {
            _requester.DeleteToken();
        }

        protected virtual void RegisterServices(IDependencyBuilder builder)
        {
            builder.AddSingleton(new AccessTokenStorage(PlayerCode));
            GD.Print($"Registered Services");
        }

        protected virtual void InitServices(string cid, string pid)
        {
            _tokenStorage = ServiceProvider.GetService<AccessTokenStorage>();
            _requester = ServiceProvider.GetService<GodotRequester>();
            _authService = ServiceProvider.GetService<IAuthApi>();
            _requester.Cid = cid;
            _requester.Pid = pid;
            GD.Print($"Initialized Services");
        }

        public bool TryGetStatFromCache(string key, out string value)
        {
            bool hasValue = Stats.TryGetValue(key, out value);
            return hasValue;
        }

        public Promise<EmptyResponse> SetPublicStat(string key, string value) => SetStat("public", key, value);

        public Promise<EmptyResponse> SetStat(string access, string key, string value)
        {
            Dictionary<string, string> stats = new Dictionary<string, string>
            {
                { key, value }
            };
            return Requester.SetStats(UserId, access, stats);
        }

        public async Promise GetStatsFromServer()
        {
            var stats = (await Requester.GetStats(UserId)).ToDictionary();
            if (stats.TryGetValue(UserId, out var stat))
            {
                Stats = stat;
            }
        }
    }
}